// This is a mock service. In a real application, this would contact your backend
// to get a short-lived, signed URL for a private media asset.

interface SignedMediaParams {
  kind: 'VIDEO' | 'AUDIO' | 'EBOOK';
  format?: 'm3u8' | 'mp4' | 'mp3' | 'pdf';
  bind: {
    userId: string;
    sessionId: string;
    ip?: string;
    uaHash: string;
  };
  ttlSec: number;
}

interface SignedMediaResponse {
  signedUrl: string;
  expiresAtISO: string;
  tokenId: string;
  policy: {
    maxBitrateKbps?: number;
    referrer?: string;
    ip?: string;
    uaHash?: string;
  };
}

interface MediaEvent {
  type: 'PLAY' | 'PAUSE' | 'SEEK' | 'ERROR' | 'RENEW' | 'BLOCKED';
  tsISO: string;
  detail?: string;
  posSec?: number;
}

type ViolationReason = 'UA_MISMATCH' | 'IP_MISMATCH' | 'REFERRER' | 'EXPIRED' | 'TAMPER' | 'MULTI_CONCURRENT';

// --- MOCK BACKEND STATE ---
const activeTokens = new Map<string, { expiresAt: number; bind: SignedMediaParams['bind']; contentId: string }>();
let violationCount = 0; // For simulating different errors

// --- HELPERS ---
const delay = (ms: number) => new Promise(res => setTimeout(res, ms));

const createUaHash = async (userAgent: string): Promise<string> => {
    // In a real app, you might use a more robust library. For modern browsers, SubtleCrypto is great.
    if (!crypto.subtle) {
        // Fallback for non-secure contexts or old browsers
        let hash = 0;
        for (let i = 0; i < userAgent.length; i++) {
            const char = userAgent.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash |= 0; // Convert to 32bit integer
        }
        return `fallback_${hash}`;
    }
    const encoder = new TextEncoder();
    const data = encoder.encode(userAgent);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 16);
};

// --- MOCK API ---

export const requestSignedMedia = async (
  siteId: string,
  contentId: string,
  rawUrl: string,
  params: SignedMediaParams
): Promise<SignedMediaResponse> => {
  await delay(400);
  console.log(`[SecureMediaService] Requesting signed URL for ${contentId}`, params);

  // Simulate server-side validation and error conditions
  violationCount++;
  if (violationCount % 10 === 0) { // Simulate a concurrency issue every 10 requests
      throw { code: 'MULTI_CONCURRENT', message: 'Another session for this content is already active.' };
  }
  if (violationCount % 7 === 0) { // Simulate a binding mismatch
       throw { code: 'UA_MISMATCH', message: 'User agent does not match the session.' };
  }

  const tokenId = `tok_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
  const expiresAt = new Date(Date.now() + params.ttlSec * 1000);
  
  activeTokens.set(tokenId, {
      expiresAt: expiresAt.getTime(),
      bind: params.bind,
      contentId,
  });

  // The signed URL would be generated by the backend. We'll simulate it.
  const signedUrl = `${rawUrl}?token=${tokenId}&expires=${expiresAt.getTime()}`;

  return {
    signedUrl,
    expiresAtISO: expiresAt.toISOString(),
    tokenId,
    policy: {
      uaHash: params.bind.uaHash,
      referrer: window.location.origin, // A real backend would validate this
    },
  };
};

export const renewSignedMedia = async (
    siteId: string,
    tokenId: string,
    rawUrl: string,
    params: Omit<SignedMediaParams, 'kind' | 'format'>
): Promise<Omit<SignedMediaResponse, 'tokenId' | 'policy'>> => {
    await delay(200);
    const existingToken = activeTokens.get(tokenId);

    if (!existingToken || existingToken.expiresAt < Date.now()) {
        throw { code: 'EXPIRED', message: 'The token has already expired and cannot be renewed.' };
    }
    if (existingToken.bind.uaHash !== params.bind.uaHash) {
         throw { code: 'UA_MISMATCH', message: 'User agent does not match the session.' };
    }

    console.log(`[SecureMediaService] Renewing token ${tokenId}`);
    const newExpiresAt = new Date(Date.now() + params.ttlSec * 1000);
    existingToken.expiresAt = newExpiresAt.getTime();
    
    const signedUrl = `${rawUrl}?token=${tokenId}&expires=${newExpiresAt.getTime()}&renewed=true`;

    return {
        signedUrl,
        expiresAtISO: newExpiresAt.toISOString(),
    };
};


export const logMediaEvent = async (siteId: string, tokenId: string, event: MediaEvent) => {
    // In a real app, this would send data to your analytics backend.
    console.log(`[Telemetry] Token ${tokenId}: ${event.type}`, event);
};

export const reportViolation = async (siteId: string, tokenId: string, reason: ViolationReason) => {
    // In a real app, this would send data to your security/monitoring backend.
    console.warn(`[Violation] Token ${tokenId}: ${reason}`);
};

export { createUaHash };
